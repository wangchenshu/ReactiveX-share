* ReactiveX

** ReactiveX
*** Rx 介紹

**** ReactiveX 的歷史
ReactiveX是Reactive Extensions的縮寫，一般簡寫為Rx，最初是LINQ的一個擴展，
由微軟的架構師Erik Meijer領導的團隊開發，在2012年11月開源，Rx是一個編程模型，
目標是提供一致的編程接口，幫助開發者更方便的處理異步數據流，Rx庫支持.NET、JavaScript和C++，
Rx近幾年越來越流行了，現在已經支持幾乎全部的流行編程語言了，Rx的大部分語言庫由ReactiveX這個組織負責維護，
比較流行的有RxJava/RxJS/Rx.NET，社區網站是reactivex.io。

**** 什麼是 ReactiveX
微軟給的定義是，Rx是一個函數庫，讓開發者可以利用可觀察序列和LINQ風格查詢操作符來編寫異步和基於事件的程序，
使用Rx，開發者可以用Observables表示異步數據流，用LINQ操作符查詢異步數據流，
用Schedulers參數化異步數據流的並發處理，Rx可以這樣定義：Rx = Observables + LINQ + Schedulers。

ReactiveX.io給的定義是，Rx是一個使用可觀察數據流進行異步編程的編程接口，ReactiveX結合了觀察者模式、
迭代器模式和函數式編程的精華。

**** ReactiveX 的應用
很多公司都在使用ReactiveX，例如Microsoft、Netflix、Github、Trello、SoundCloud。

*** Rx 模式

**** 使用觀察者模式
***** 創建
Rx可以方便的創建事件流和數據流

***** 組合
Rx使用查詢式的操作符組合和變換數據流

***** 監聽
Rx可以訂閱任何可觀察的數據流並執行操作

**** 簡化代碼
***** 函數式風格
對可觀察數據流使用無副作用的輸入輸出函數，避免了程序裡錯綜複雜的狀態

***** 簡化代碼
Rx的操作符通通常可以將復雜的難題簡化為很少的幾行代碼

***** 異步錯誤處理
傳統的try/catch沒辦法處理異步計算，Rx提供了合適的錯誤處理機制

***** 輕鬆使用並發
Rx的Observables和Schedulers讓開發者可以擺脫底層的線程同步和各種並發問題

**** 使用Observable的優勢
Rx擴展了觀察者模式用於支持數據和事件序列，添加了一些操作符，它讓你可以聲明式的組合這些序列，
而無需關注底層的實現：如線程、同步、線程安全、並發數據結構和非阻塞IO。

Observable通過使用最佳的方式訪問異步數據序列填補了這個間隙。
Rx的Observable模型讓你可以像使用集合數據一樣操作異步事件流，對異步事件流使用各種簡單、可組合的操作。

***** Observable可組合
對於單層的異步操作來說，Java中Future對象的處理方式是非常簡單有效的，但是一旦涉及到嵌套，
它們就開始變得異常繁瑣和復雜。使用Future很難很好的組合帶條件的異步執行流程
（考慮到運行時各種潛在的問題，甚至可以說是不可能的），當然，要想實現還是可以做到的，但是非常困難，
或許你可以用Future.get()，但這樣做，異步執行的優勢就完全沒有了。
從另一方面說，Rx的Observable一開始就是為組合異步數據流準備的。

***** Observable更靈活
Rx的Observable不僅支持處理單獨的標量值（就像Future可以做的），也支持數據序列，甚至是無窮的數據流。
Observable是一個抽象概念，適用於任何場景。 Observable擁有它的近親Iterable的全部優雅與靈活。

Observable是異步的雙向push，Iterable是同步的單向pull。

***** Observable無偏見
Rx對於對於並發性或異步性沒有任何特殊的偏好，Observable可以用任何方式實現，線程池、事件循環、非阻塞IO、Actor模式，
任何滿足你的需求的，你擅長或偏好的方式都可以。無論你選擇怎樣實現它，無論底層實現是阻塞的還是非阻塞的，
客戶端代碼將所有與Observable的交互都當做是異步的。

****** Observable是如何實現的？
#+NAME: 
#+BEGIN_SRC
public Observable<data> getData();
#+END_SRC

****** 使用回調存在很多問題
回調在不阻塞任何事情的情況下，解決了Future.get()過早阻塞的問題。由於響應結果一旦就緒Callback就會被調用，
它們天生就是高效率的。不過，就像使用Future一樣，對於單層的異步執行來說，回調很容易使用，對於嵌套的異步組合，它們顯得非常笨拙。

****** Rx是一個多語言的實現
Rx在大量的編程語言中都有實現，並尊重實現語言的風格，而且更多的實現正在飛速增加。

****** 響應式編程
Rx提供了一系列的操作符，你可以使用它們來過濾(filter)、選擇(select)、變換(transform)、結合(combine)和組合(compose)多個Observable，
這些操作符讓執行和復合變得非常高效。

你可以把Observable當做Iterable的推送方式的等價物，使用Iterable，消費者從生產者那拉取數據，線程阻塞直至數據準備好。使用Observable，
在數據準備好時，生產者將數據推送給消費者。數據可以同步或異步的到達，這種方式更靈活。

下面的例子展示了相似的高階函數在Iterable和Observable上的應用
#+NAME: 
#+BEGIN_SRC
// Iterable
getDataFromLocalMemory()
  .skip(10)
  .take(5)
  .map({ s -> return s + " transformed" })
  .forEach({ println "next => " + it })

// Observable
getDataFromNetwork()
  .skip(10)
  .take(5)
  .map({ s -> return s + " transformed" })
  .subscribe({ println "onNext => " + it })
#+END_SRC

Observable類型給GOF的觀察者模式添加了兩種缺少的語義，這樣就和Iterable類型中可用的操作一致了：
1. 生產者可以發信號給消費者，通知它沒有更多數據可用了（對於Iterable，一個for循環正常完成表示沒有數據了；對於Observable，就是調用觀察者的onCompleted方法）
2. 生產者可以發信號給消費者，通知它遇到了一個錯誤（對於Iterable，迭代過程中發生錯誤會拋出異常；對於Observable，就是調用觀察者(Observer)的onError方法）

有了這兩種功能，Rx就能使Observable與Iterable保持一致了，唯一的不同是數據流的方向。任何對Iterable的操作，你都可以對Observable使用。

**** 名詞定義
這裡給出一些名詞的翻譯

Reactive 直譯為反應性的，有活性的，根據上下文一般翻譯為反應式、響應式
Iterable 可迭代對象，支持以迭代器的形式遍歷，許多語言中都存在這個概念
Observable 可觀察對象，在Rx中定義為更強大的Iterable，在觀察者模式中是被觀察的對象，一旦數據產生或發生變化，會通過某種方式通知觀察者或訂閱者
Observer 觀察者對象，監聽Observable發射的數據並做出響應，Subscriber是它的一個特殊實現
emit 直譯為發射，發布，發出，含義是Observable在數據產生或變化時發送通知給Observer，調用Observer對應的方法，文章裡一律譯為發射
items 直譯為項目，條目，在Rx裡是指Observable發射的數據項，文章裡一律譯為數據，數據項

** Observable
*** 概述
在ReactiveX中，一個觀察者(Observer)訂閱一個可觀察對象(Observable)。觀察者對Observable發射的數據或數據序列作出響應。
這種模式可以極大地簡化並發操作，因為它創建了一個處於待命狀態的觀察者哨兵，在未來某個時刻響應Observable的通知，不需要阻塞等待Observable發射數據。

這篇文章會解釋什麼是響應式編程模式(reactive pattern)，以及什麼是可觀察對象(Observables)和觀察者(observers)，
其它幾篇文章會展示如何用操作符組合和改變Observable的行為。

https://mcxiaoke.gitbooks.io/rxdocs/content/images/legend.png

*** 背景知識
在很多軟件編程任務中，或多或少你都會期望你寫的代碼能按照編寫的順序，一次一個的順序執行和完成。但是在ReactiveX中，很多指令可能是並行執行的，
之後他們的執行結果才會被觀察者捕獲，順序是不確定的。為達到這個目的，你定義一種獲取和變換數據的機制，而不是調用一個方法。在這種機制下，
存在一個可觀察對象(Observable)，觀察者(Observer)訂閱(Subscribe)它，當數據就緒時，之前定義的機制就會分發數據給一直處於等待狀態的觀察者哨兵。

這種方法的優點是，如果你有大量的任務要處理，它們互相之間沒有依賴關係。你可以同時開始執行它們，不用等待一個完成再開始下一個
（用這種方式，你的整個任務隊列能耗費的最長時間，不會超過任務裡最耗時的那個）。

有很多術語可用於描述這種異步編程和設計模式，在在本文裡我們使用這些術語：一個觀察者訂閱一個可觀察對象 (An observer subscribes to an Observable)。
通過調用觀察者的方法，Observable發射數據或通知給它的觀察者。

在其它的文檔和場景裡，有時我們也將Observer叫做Subscriber、Watcher、Reactor。這個模型通常被稱作Reactor模式。

*** 創建觀察者
本文使用類似於Groovy的偽代碼舉例，但是ReactiveX有多種語言的實現。

普通的方法調用（不是某種異步方法，也不是Rx中的並行調用），流程通常是這樣的：
1. 調用某一個方法
2. 用一個變量保存方法返回的結果
3. 使用這個變量和它的新值做些有用的事

用代碼描述就是：
#+NAME: 
#+BEGIN_SRC
// make the call, assign its return value to `returnVal`
returnVal = someMethod(itsParameters);
// do something useful with returnVal
#+END_SRC

在異步模型中流程更像這樣的：
1. 定義一個方法，它完成某些任務，然後從異步調用中返回一個值，這個方法是觀察者的一部分
2. 將這個異步調用本身定義為一個Observable
3. 觀察者通過訂閱(Subscribe)操作關聯到那個Observable
4. 繼續你的業務邏輯，等方法返回時，Observable會發射結果，觀察者的方法會開始處理結果或結果集

用代碼描述就是：
#+NAME: 
#+BEGIN_SRC sample.kt
val ob = (0..10).toObservable().map { it + 1 }

ob.subscribe { it -> println(it) }
#+END_SRC

**** 回調方法 (onNext, onCompleted, onError)
Subscribe方法用於將觀察者連接到Observable，你的觀察者需要實現以下方法的一個子集：

***** onNext(T item)
Observable調用這個方法發射數據，方法的參數就是Observable發射的數據，這個方法可能會被調用多次，取決於你的實現。

***** onError(Exception ex)
當Observable遇到錯誤或者無法返回期望的數據時會調用這個方法，這個調用會終止Observable，
後續不會再調用onNext和onCompleted，onError方法的參數是拋出的異常。

***** onComplete
正常終止，如果沒有遇到錯誤，Observable在最後一次調用onNext之後調用此方法。

根據Observable協議的定義，onNext可能會被調用零次或者很​​多次，最後會有一次onCompleted或onError調用（不會同時），
傳遞數據給onNext通常被稱作發射，onCompleted和onError被稱作通知。

下面是一個更完整的例子：
#+NAME: 
#+BEGIN_SRC sample2.kt
val myOnNext = { it -> /* do something useful with it */ };
val myError = { throwable -> /* react sensibly to a failed call */ };
val myComplete = { /* clean up after the final response */ };
val myObservable = someMethod(itsParameters);

myObservable.subscribe(myOnNext, myError, myComplete);
// go on about my business
#+END_SRC

**** 取消訂閱 (Unsubscribing)
在一些ReactiveX實現中，有一個特殊的觀察者接口Subscriber，它有一個unsubscribe方法。
調用這個方法表示你不關心當前訂閱的Observable了，因此Observable可以選擇停止發射新的數據項（如果沒有其它觀察者訂閱）。

取消訂閱的結果會傳遞給這個Observable的操作符鏈，而且會導致這個鏈條上的每個環節都停止發射數據項。這些並不保證會立即發生，
然而，對一個Observable來說，即使沒有觀察者了，它也可以在一個while循環中繼續生成並嘗試發射數據項。

**** 關於命名約定
ReactiveX的每種特定語言的實現都有自己的命名偏好，雖然不同的實現之間有很多共同點，但並不存在一個統一的命名標準。
而且，在某些場景中，一些名字有不同的隱含意義，或者在某些語言看來比較怪異。

例如，有一個onEvent命名模式(onNext, onCompleted, onError)，在一些場景中，這些名字可能意味著事件處理器已經註冊。
然而在ReactiveX裡，他們是事件處理器的名字。

*** Observables的"熱"和"冷"
Observable什麼時候開始發射數據序列？這取決於Observable的實現，

一個"熱"的Observable可能一創建完就開始發射數據，
因此所有後續訂閱它的觀察者可能從序列中間的某個位置開始接受數據（有一些數據錯過了）。

一個"冷"的Observable會一直等待，
直到有觀察者訂閱它才開始發射數據，因此這個觀察者可以確保會收到整個數據序列。

在一些ReactiveX實現裡，還存在一種被稱作Connectable的Observable，不管有沒有觀察者訂閱它，這種Observable都不會開始發射數據，
除非Connect方法被調用。

*** 用操作符組合 Observable
對於ReactiveX來說，Observable和Observer僅僅是個開始，它們本身不過是標準觀察者模式的一些輕量級擴展，目的是為了更好的處理事件序列。

ReactiveX真正強大的地方在於它的操作符，操作符讓你可以變換、組合、操縱和處理Observable發射的數據。

Rx的操作符讓你可以用聲明式的風格組合異步操作序列，它擁有回調的所有效率優勢，同時又避免了典型的異步系統中嵌套回調的缺點。

下面是常用的操作符列表：
 1. 創建操作 Create, Defer, Empty/Never/Throw, From, Interval, Just, Range, Repeat, Start, Timer
 2. 變換操作 Buffer, FlatMap, GroupBy, Map, Scan, Window
 3. 過濾操作 Debounce, Distinct, ElementAt, Filter, First, IgnoreElements, Last, Sample, Skip, SkipLast, Take, TakeLast
 4. 組合操作 And/Then/When, CombineLatest, Join, Merge, StartWith, Switch, Zip
 5. 錯誤處理 Catch, Retry
 6. 輔助操作 Delay, Do, Materialize/Dematerialize, ObserveOn, Serialize, Subscribe, SubscribeOn, TimeInterval, Timeout, Timestamp, Using
 7. 條件和布林操作 All, Amb, Contains, DefaultIfEmpty, SequenceEqual, SkipUntil, SkipWhile, TakeUntil, TakeWhile
 8. 算術和集合操作 Average, Concat, Count, Max, Min, Reduce, Sum
 9. 轉換操作 To
10. 連接操作 Connect, Publish, RefCount, Replay
11. 反壓操作, 用於增加特殊的流程控制策略的操作符

這些操作符並不全都是ReactiveX的核心組成部分，有一些是語言特定的實現或可選的模塊。

*** RxJava
在RxJava中，一個實現了Observer接口的對象可以訂閱(subscribe)一個Observable 類的實例。
訂閱者(subscriber)對Observable發射(emit)的任何數據或數據序列作出響應。這種模式簡化了並發操作，
因為它不需要阻塞等待Observable發射數據，而是創建了一個處於待命狀態的觀察者哨兵，哨兵在未來某個時刻響應Observable的通知。

** Single
*** 介紹
RxJava（以及它派生出來的RxGroovy和RxScala）中有一個名為Single的Observable變種。
Single類似於Observable，不同的是，它總是只發射一個值，或者一個錯誤通知，而不是發射一系列的值。
因此，不同於Observable需要三個方法onNext, onError, onCompleted，訂閱Single只需要兩個方法：

onSuccess - Single發射單個的值到這個方法
onError - 如果無法發射需要的值，Single發射一個Throwable對像到這個方法
Single只會調用這兩個方法中的一個，而且只會調用一次，調用了任何一個方法之後，訂閱關係終止。

*** Single的操作符
Single也可以組合使用多種操作，一些操作符讓你可以混合使用Observable和Single：

| 操作符                | 返回值     | 說明                                                                                                 |
|-----------------------+------------+------------------------------------------------------------------------------------------------------|
| compose               | Single     | 創建一個自定義的操作符                                                                               |
| concat and concatWith | Observable | 連接多個Single和Observable發射的數據                                                                   |
| create                | Single     | 調用觀察者的create方法創建一個Single                                                                 |
| error                 | Single     | 返回一個立即給訂閱者發射錯誤通知的Single                                                             |
| flatMap               | Single     | 返回一個Single，它發射對原Single的數據執行flatMap操作後的結果                                        |
| flatMapObservable     | Observable | 返回一個Observable，它發射對原Single的數據執行flatMap操作後的結果                                    |
| from                  | Single     | 將Future轉換成Single                                                                                 |
| just                  | Single     | 返回一個發射一個指定值的Single                                                                       |
| map                   | Single     | 返回一個Single，它發射對原Single的數據執行map操作後的結果                                            |
| merge                 | Single     | 將一個Single(它發射的數據是另一個Single，假設為B)轉換成另一個Single(它發射來自另一個Single(B)的數據) |
| merge and mergeWith   | Observable | 合併發射來自多個Single的數據                                                                         |
| observeOn             | Single     | 指示Single在指定的調度程序上調用訂閱者的方法                                                         |
| onErrorReturn         | Single     | 將一個發射錯誤通知的Single轉換成一個發射指定數據項的Single                                           |
| subscribeOn           | Single     | 指示Single在指定的調度程序上執行操作                                                                 |
| timeout               | Single     | 它給原有的Single添加超時控制，如果超時了就發射一個錯誤通知                                           |
| toSingle              | Single     | 將一個發射單個值的Observable轉換為一個Single                                                         |
| zip and zipWith       | Single     | 將多個Single轉換為一個，後者發射的數據是對前者應用一個函數後的結果                                   |

*** 操作符圖示
詳細的圖解可以參考英文文檔：[[http://reactivex.io/documentation/single.html][Single]]

** Subject
Subject可以看成是一個橋樑或者代理，在某些ReactiveX實現中（如RxJava），它同時充當了Observer和Observable的角色。
因為它是一個Observer，它可以訂閱一個或多個Observable；又因為它是一個Observable，它可以轉發它收到(Observe)的數據，
也可以發射新的數據。

由於一個Subject訂閱一個Observable，它可以觸發這個Observable開始發射數據
（如果那個Observable是"冷"的--就是說，它等待有訂閱才開始發射數據）。
因此有這樣的效果，Subject可以把原來那個"冷"的Observable變成"熱"的。

*** Subject的種類
針對不同的場景一共有四種類型的Subject。他們並不是在所有的實現中全部都存在，
而且一些實現使用其它的命名約定（例如，在RxScala中Subject被稱作PublishSubject）。

**** AsyncSubject
一個AsyncSubject只在原始Observable完成後，發射來自原始Observable的最後一個值。
（如果原始Observable沒有發射任何值，AsyncObject也不發射任何值）它會把這最後一個值發射給任何後續的觀察者。

https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.AsyncSubject.png

然而，如果原始的Observable因為發生了錯誤而終止，AsyncSubject將不會發射任何數據，只是簡單的向前傳遞這個錯誤通知。

https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.AsyncSubject.e.png

**** BehaviorSubject
當觀察者訂閱BehaviorSubject時，它開始發射原始Observable最近發射的數據
（如果此時還沒有收到任何數據，它會發射一個默認值），然後繼續發射其它任何來自原始Observable的數據。
https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.BehaviorSubject.png

然而，如果原始的Observable因為發生了一個錯誤而終止，BehaviorSubject將不會發射任何數據，只是簡單的向前傳遞這個錯誤通知。

https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.BehaviorSubject.e.png

**** PublishSubject
PublishSubject只會把在訂閱發生的時間點之後來自原始Observable的數據發射給觀察者。
需要注意的是，PublishSubject可能會一創建完成就立刻開始發射數據（除非你可以阻止它發生），
因此這裡有一個風險：在Subject被創建後到有觀察者訂閱它之前這個時間段內，一個或多個數據可能會丟失。
如果要確保來自原始Observable的所有數據都被分發，你需要這樣做：
或者使用Create創建那個Observable以便手動給它引入"冷"Observable的行為
（當所有觀察者都已經訂閱時才開始發射數據），或者改用ReplaySubject。

https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.PublishSubject.png

如果原始的Observable因為發生了一個錯誤而終止，PublishSubject將不會發射任何數據，只是簡單的向前傳遞這個錯誤通知。

https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.PublishSubject.e.png

**** ReplaySubject
ReplaySubject會發射所有來自原始Observable的數據給觀察者，無論它們是何時訂閱的。也有其它版本的ReplaySubject，
在重放緩存增長到一定大小的時候或過了一段時間後會丟棄舊的數據（原始Observable發射的）。

如果你把ReplaySubject當作一個觀察者使用，注意不要從多個線程中調用它的onNext方法（包括其它的on系列方法），
這可能導致同時（非順序）調用，這會違反Observable協議，給Subject的結果增加了不確定性。

https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.ReplaySubject.png

*** RxJava的對應類
假設你有一個Subject，你想把它傳遞給其它的代理或者暴露它的Subscriber接口，你可以調用它的asObservable方法，
這個方法返回一個Observable。具體使用方法可以參考Javadoc文檔。

**** 串行化
如果你把Subject 當作一個Subscriber 使用，注意不要從多個線程中調用它的onNext方法（包括其它的on系列方法），
這可能導致同時（非順序）調用，這會違反Observable協議，給Subject的結果增加了不確定性。

要避免此類問題，你可以將 Subject 轉換為一個 SerializedSubject ，類似於這樣：

#+NAME:
#+BEGIN_SRC
mySafeSubject = new SerializedSubject( myUnsafeSubject );
#+END_SRC

** 調度器 Scheduler
如果你想給Observable操作符鏈添加多線程功能，你可以指定操作符（或者特定的Observable）在特定的調度器(Scheduler)上執行。

某些ReactiveX的Observable操作符有一些變體，它們可以接受一個Scheduler參數。
這個參數指定操作符將它們的部分或全部任務放在一個特定的調度器上執行。

使用ObserveOn和SubscribeOn操作符，你可以讓Observable在一個特定的調度器上執行，
ObserveOn指示一個Observable在一個特定的調度器上調用觀察者的 onNext, onError和onCompleted方法，
SubscribeOn更進一步，它指示Observable將全部的處理過程（包括發射數據和通知）放在特定的調度器上執行。
