* ReactiveX

** ReactiveX
翻譯自 https://mcxiaoke.gitbooks.io/rxdocs/content/

*** Rx 介紹

**** ReactiveX 的歷史
ReactiveX是Reactive Extensions的縮寫，一般簡寫為Rx，最初是LINQ的一個擴展，
由微軟的架構師Erik Meijer領導的團隊開發，在2012年11月開源，Rx是一個編程模型，
目標是提供一致的編程接口，幫助開發者更方便的處理異步數據流，Rx庫支持.NET、JavaScript和C++，
Rx近幾年越來越流行了，現在已經支持幾乎全部的流行編程語言了，Rx的大部分語言庫由ReactiveX這個組織負責維護，
比較流行的有RxJava/RxJS/Rx.NET，社區網站是reactivex.io。

**** 什麼是 ReactiveX
微軟給的定義是，Rx是一個函數庫，讓開發者可以利用可觀察序列和LINQ風格查詢操作符來編寫異步和基於事件的程序，
使用Rx，開發者可以用Observables表示異步數據流，用LINQ操作符查詢異步數據流，
用Schedulers參數化異步數據流的並發處理，Rx可以這樣定義：Rx = Observables + LINQ + Schedulers。

ReactiveX.io給的定義是，Rx是一個使用可觀察數據流進行異步編程的編程接口，ReactiveX結合了觀察者模式、
迭代器模式和函數式編程的精華。

**** ReactiveX 的應用
很多公司都在使用ReactiveX，例如Microsoft、Netflix、Github、Trello、SoundCloud。

*** Rx 模式

**** 使用觀察者模式
***** 創建
Rx可以方便的創建事件流和數據流

***** 組合
Rx使用查詢式的操作符組合和變換數據流

***** 監聽
Rx可以訂閱任何可觀察的數據流並執行操作

**** 簡化代碼
***** 函數式風格
對可觀察數據流使用無副作用的輸入輸出函數，避免了程序裡錯綜複雜的狀態

***** 簡化代碼
Rx的操作符通通常可以將復雜的難題簡化為很少的幾行代碼

***** 異步錯誤處理
傳統的try/catch沒辦法處理異步計算，Rx提供了合適的錯誤處理機制

***** 輕鬆使用並發
Rx的Observables和Schedulers讓開發者可以擺脫底層的線程同步和各種並發問題

**** 使用Observable的優勢
Rx擴展了觀察者模式用於支持數據和事件序列，添加了一些操作符，它讓你可以聲明式的組合這些序列，
而無需關注底層的實現：如線程、同步、線程安全、並發數據結構和非阻塞IO。

Observable通過使用最佳的方式訪問異步數據序列填補了這個間隙。
Rx的Observable模型讓你可以像使用集合數據一樣操作異步事件流，對異步事件流使用各種簡單、可組合的操作。

***** Observable可組合
對於單層的異步操作來說，Java中Future對象的處理方式是非常簡單有效的，但是一旦涉及到嵌套，
它們就開始變得異常繁瑣和復雜。使用Future很難很好的組合帶條件的異步執行流程
（考慮到運行時各種潛在的問題，甚至可以說是不可能的），當然，要想實現還是可以做到的，但是非常困難，
或許你可以用Future.get()，但這樣做，異步執行的優勢就完全沒有了。
從另一方面說，Rx的Observable一開始就是為組合異步數據流準備的。

***** Observable更靈活
Rx的Observable不僅支持處理單獨的標量值（就像Future可以做的），也支持數據序列，甚至是無窮的數據流。
Observable是一個抽象概念，適用於任何場景。 Observable擁有它的近親Iterable的全部優雅與靈活。

Observable是異步的雙向push，Iterable是同步的單向pull。

***** Observable無偏見
Rx對於對於並發性或異步性沒有任何特殊的偏好，Observable可以用任何方式實現，線程池、事件循環、非阻塞IO、Actor模式，
任何滿足你的需求的，你擅長或偏好的方式都可以。無論你選擇怎樣實現它，無論底層實現是阻塞的還是非阻塞的，
客戶端代碼將所有與Observable的交互都當做是異步的。

****** Observable是如何實現的？
#+NAME: 
#+BEGIN_SRC
public Observable<data> getData();
#+END_SRC

****** 使用回調存在很多問題
回調在不阻塞任何事情的情況下，解決了Future.get()過早阻塞的問題。由於響應結果一旦就緒Callback就會被調用，
它們天生就是高效率的。不過，就像使用Future一樣，對於單層的異步執行來說，回調很容易使用，對於嵌套的異步組合，它們顯得非常笨拙。

****** Rx是一個多語言的實現
Rx在大量的編程語言中都有實現，並尊重實現語言的風格，而且更多的實現正在飛速增加。

****** 響應式編程
Rx提供了一系列的操作符，你可以使用它們來過濾(filter)、選擇(select)、變換(transform)、結合(combine)和組合(compose)多個Observable，
這些操作符讓執行和復合變得非常高效。

你可以把Observable當做Iterable的推送方式的等價物，使用Iterable，消費者從生產者那拉取數據，線程阻塞直至數據準備好。使用Observable，
在數據準備好時，生產者將數據推送給消費者。數據可以同步或異步的到達，這種方式更靈活。

下面的例子展示了相似的高階函數在Iterable和Observable上的應用
#+NAME: 
#+BEGIN_SRC
// Iterable
getDataFromLocalMemory()
  .skip(10)
  .take(5)
  .map({ s -> return s + " transformed" })
  .forEach({ println "next => " + it })

// Observable
getDataFromNetwork()
  .skip(10)
  .take(5)
  .map({ s -> return s + " transformed" })
  .subscribe({ println "onNext => " + it })
#+END_SRC

Observable類型給GOF的觀察者模式添加了兩種缺少的語義，這樣就和Iterable類型中可用的操作一致了：
1. 生產者可以發信號給消費者，通知它沒有更多數據可用了（對於Iterable，一個for循環正常完成表示沒有數據了；對於Observable，就是調用觀察者的onCompleted方法）
2. 生產者可以發信號給消費者，通知它遇到了一個錯誤（對於Iterable，迭代過程中發生錯誤會拋出異常；對於Observable，就是調用觀察者(Observer)的onError方法）

有了這兩種功能，Rx就能使Observable與Iterable保持一致了，唯一的不同是數據流的方向。任何對Iterable的操作，你都可以對Observable使用。

**** 名詞定義
這裡給出一些名詞的翻譯

Reactive 直譯為反應性的，有活性的，根據上下文一般翻譯為反應式、響應式
Iterable 可迭代對象，支持以迭代器的形式遍歷，許多語言中都存在這個概念
Observable 可觀察對象，在Rx中定義為更強大的Iterable，在觀察者模式中是被觀察的對象，一旦數據產生或發生變化，會通過某種方式通知觀察者或訂閱者
Observer 觀察者對象，監聽Observable發射的數據並做出響應，Subscriber是它的一個特殊實現
emit 直譯為發射，發布，發出，含義是Observable在數據產生或變化時發送通知給Observer，調用Observer對應的方法，文章裡一律譯為發射
items 直譯為項目，條目，在Rx裡是指Observable發射的數據項，文章裡一律譯為數據，數據項

** Observable
*** 概述
在ReactiveX中，一個觀察者(Observer)訂閱一個可觀察對象(Observable)。觀察者對Observable發射的數據或數據序列作出響應。
這種模式可以極大地簡化並發操作，因為它創建了一個處於待命狀態的觀察者哨兵，在未來某個時刻響應Observable的通知，不需要阻塞等待Observable發射數據。

這篇文章會解釋什麼是響應式編程模式(reactive pattern)，以及什麼是可觀察對象(Observables)和觀察者(observers)，
其它幾篇文章會展示如何用操作符組合和改變Observable的行為。

[[https://mcxiaoke.gitbooks.io/rxdocs/content/images/legend.png]]

*** 背景知識
在很多軟件編程任務中，或多或少你都會期望你寫的代碼能按照編寫的順序，一次一個的順序執行和完成。但是在ReactiveX中，很多指令可能是並行執行的，
之後他們的執行結果才會被觀察者捕獲，順序是不確定的。為達到這個目的，你定義一種獲取和變換數據的機制，而不是調用一個方法。在這種機制下，
存在一個可觀察對象(Observable)，觀察者(Observer)訂閱(Subscribe)它，當數據就緒時，之前定義的機制就會分發數據給一直處於等待狀態的觀察者哨兵。

這種方法的優點是，如果你有大量的任務要處理，它們互相之間沒有依賴關係。你可以同時開始執行它們，不用等待一個完成再開始下一個
（用這種方式，你的整個任務隊列能耗費的最長時間，不會超過任務裡最耗時的那個）。

有很多術語可用於描述這種異步編程和設計模式，在在本文裡我們使用這些術語：一個觀察者訂閱一個可觀察對象 (An observer subscribes to an Observable)。
通過調用觀察者的方法，Observable發射數據或通知給它的觀察者。

在其它的文檔和場景裡，有時我們也將Observer叫做Subscriber、Watcher、Reactor。這個模型通常被稱作Reactor模式。

*** 創建觀察者
本文使用類似於Groovy的偽代碼舉例，但是ReactiveX有多種語言的實現。

普通的方法調用（不是某種異步方法，也不是Rx中的並行調用），流程通常是這樣的：
1. 調用某一個方法
2. 用一個變量保存方法返回的結果
3. 使用這個變量和它的新值做些有用的事

用代碼描述就是：
#+NAME: 
#+BEGIN_SRC
// make the call, assign its return value to `returnVal`
returnVal = someMethod(itsParameters);
// do something useful with returnVal
#+END_SRC

在異步模型中流程更像這樣的：
1. 定義一個方法，它完成某些任務，然後從異步調用中返回一個值，這個方法是觀察者的一部分
2. 將這個異步調用本身定義為一個Observable
3. 觀察者通過訂閱(Subscribe)操作關聯到那個Observable
4. 繼續你的業務邏輯，等方法返回時，Observable會發射結果，觀察者的方法會開始處理結果或結果集

用代碼描述就是：
#+NAME: 
#+BEGIN_SRC sample.kt
val ob = (0..10).toObservable().map { it + 1 }

ob.subscribe { it -> println(it) }
#+END_SRC

**** 回調方法 (onNext, onCompleted, onError)
Subscribe方法用於將觀察者連接到Observable，你的觀察者需要實現以下方法的一個子集：

***** onNext(T item)
Observable調用這個方法發射數據，方法的參數就是Observable發射的數據，這個方法可能會被調用多次，取決於你的實現。

***** onError(Exception ex)
當Observable遇到錯誤或者無法返回期望的數據時會調用這個方法，這個調用會終止Observable，
後續不會再調用onNext和onCompleted，onError方法的參數是拋出的異常。

***** onComplete
正常終止，如果沒有遇到錯誤，Observable在最後一次調用onNext之後調用此方法。

根據Observable協議的定義，onNext可能會被調用零次或者很​​多次，最後會有一次onCompleted或onError調用（不會同時），
傳遞數據給onNext通常被稱作發射，onCompleted和onError被稱作通知。

下面是一個更完整的例子：
#+NAME: 
#+BEGIN_SRC sample2.kt
val myOnNext = { it -> /* do something useful with it */ };
val myError = { throwable -> /* react sensibly to a failed call */ };
val myComplete = { /* clean up after the final response */ };
val myObservable = someMethod(itsParameters);

myObservable.subscribe(myOnNext, myError, myComplete);
// go on about my business
#+END_SRC

**** 取消訂閱 (Unsubscribing)
在一些ReactiveX實現中，有一個特殊的觀察者接口Subscriber，它有一個unsubscribe方法。
調用這個方法表示你不關心當前訂閱的Observable了，因此Observable可以選擇停止發射新的數據項（如果沒有其它觀察者訂閱）。

取消訂閱的結果會傳遞給這個Observable的操作符鏈，而且會導致這個鏈條上的每個環節都停止發射數據項。這些並不保證會立即發生，
然而，對一個Observable來說，即使沒有觀察者了，它也可以在一個while循環中繼續生成並嘗試發射數據項。

**** 關於命名約定
ReactiveX的每種特定語言的實現都有自己的命名偏好，雖然不同的實現之間有很多共同點，但並不存在一個統一的命名標準。
而且，在某些場景中，一些名字有不同的隱含意義，或者在某些語言看來比較怪異。

例如，有一個onEvent命名模式(onNext, onCompleted, onError)，在一些場景中，這些名字可能意味著事件處理器已經註冊。
然而在ReactiveX裡，他們是事件處理器的名字。

*** Observables的"熱"和"冷"
Observable什麼時候開始發射數據序列？這取決於Observable的實現，

一個"熱"的Observable可能一創建完就開始發射數據，
因此所有後續訂閱它的觀察者可能從序列中間的某個位置開始接受數據（有一些數據錯過了）。

一個"冷"的Observable會一直等待，
直到有觀察者訂閱它才開始發射數據，因此這個觀察者可以確保會收到整個數據序列。

在一些ReactiveX實現裡，還存在一種被稱作Connectable的Observable，不管有沒有觀察者訂閱它，這種Observable都不會開始發射數據，
除非Connect方法被調用。

*** 用操作符組合 Observable
對於ReactiveX來說，Observable和Observer僅僅是個開始，它們本身不過是標準觀察者模式的一些輕量級擴展，目的是為了更好的處理事件序列。

ReactiveX真正強大的地方在於它的操作符，操作符讓你可以變換、組合、操縱和處理Observable發射的數據。

Rx的操作符讓你可以用聲明式的風格組合異步操作序列，它擁有回調的所有效率優勢，同時又避免了典型的異步系統中嵌套回調的缺點。

下面是常用的操作符列表：
 1. 創建操作 Create, Defer, Empty/Never/Throw, From, Interval, Just, Range, Repeat, Start, Timer
 2. 變換操作 Buffer, FlatMap, GroupBy, Map, Scan, Window
 3. 過濾操作 Debounce, Distinct, ElementAt, Filter, First, IgnoreElements, Last, Sample, Skip, SkipLast, Take, TakeLast
 4. 組合操作 And/Then/When, CombineLatest, Join, Merge, StartWith, Switch, Zip
 5. 錯誤處理 Catch, Retry
 6. 輔助操作 Delay, Do, Materialize/Dematerialize, ObserveOn, Serialize, Subscribe, SubscribeOn, TimeInterval, Timeout, Timestamp, Using
 7. 條件和布林操作 All, Amb, Contains, DefaultIfEmpty, SequenceEqual, SkipUntil, SkipWhile, TakeUntil, TakeWhile
 8. 算術和集合操作 Average, Concat, Count, Max, Min, Reduce, Sum
 9. 轉換操作 To
10. 連接操作 Connect, Publish, RefCount, Replay
11. 反壓操作, 用於增加特殊的流程控制策略的操作符

這些操作符並不全都是ReactiveX的核心組成部分，有一些是語言特定的實現或可選的模塊。

*** RxJava
在RxJava中，一個實現了Observer接口的對象可以訂閱(subscribe)一個Observable 類的實例。
訂閱者(subscriber)對Observable發射(emit)的任何數據或數據序列作出響應。這種模式簡化了並發操作，
因為它不需要阻塞等待Observable發射數據，而是創建了一個處於待命狀態的觀察者哨兵，哨兵在未來某個時刻響應Observable的通知。

** Single
*** 介紹
RxJava（以及它派生出來的RxGroovy和RxScala）中有一個名為Single的Observable變種。
Single類似於Observable，不同的是，它總是只發射一個值，或者一個錯誤通知，而不是發射一系列的值。
因此，不同於Observable需要三個方法onNext, onError, onCompleted，訂閱Single只需要兩個方法：

onSuccess - Single發射單個的值到這個方法
onError - 如果無法發射需要的值，Single發射一個Throwable對像到這個方法
Single只會調用這兩個方法中的一個，而且只會調用一次，調用了任何一個方法之後，訂閱關係終止。

*** Single的操作符
Single也可以組合使用多種操作，一些操作符讓你可以混合使用Observable和Single：

| 操作符                | 返回值     | 說明                                                                                                 |
|-----------------------+------------+------------------------------------------------------------------------------------------------------|
| compose               | Single     | 創建一個自定義的操作符                                                                               |
| concat and concatWith | Observable | 連接多個Single和Observable發射的數據                                                                   |
| create                | Single     | 調用觀察者的create方法創建一個Single                                                                 |
| error                 | Single     | 返回一個立即給訂閱者發射錯誤通知的Single                                                             |
| flatMap               | Single     | 返回一個Single，它發射對原Single的數據執行flatMap操作後的結果                                        |
| flatMapObservable     | Observable | 返回一個Observable，它發射對原Single的數據執行flatMap操作後的結果                                    |
| from                  | Single     | 將Future轉換成Single                                                                                 |
| just                  | Single     | 返回一個發射一個指定值的Single                                                                       |
| map                   | Single     | 返回一個Single，它發射對原Single的數據執行map操作後的結果                                            |
| merge                 | Single     | 將一個Single(它發射的數據是另一個Single，假設為B)轉換成另一個Single(它發射來自另一個Single(B)的數據) |
| merge and mergeWith   | Observable | 合併發射來自多個Single的數據                                                                         |
| observeOn             | Single     | 指示Single在指定的調度程序上調用訂閱者的方法                                                         |
| onErrorReturn         | Single     | 將一個發射錯誤通知的Single轉換成一個發射指定數據項的Single                                           |
| subscribeOn           | Single     | 指示Single在指定的調度程序上執行操作                                                                 |
| timeout               | Single     | 它給原有的Single添加超時控制，如果超時了就發射一個錯誤通知                                           |
| toSingle              | Single     | 將一個發射單個值的Observable轉換為一個Single                                                         |
| zip and zipWith       | Single     | 將多個Single轉換為一個，後者發射的數據是對前者應用一個函數後的結果                                   |

*** 操作符圖示
詳細的圖解可以參考英文文檔：[[http://reactivex.io/documentation/single.html][Single]]

** Subject
Subject可以看成是一個橋樑或者代理，在某些ReactiveX實現中（如RxJava），它同時充當了Observer和Observable的角色。
因為它是一個Observer，它可以訂閱一個或多個Observable；又因為它是一個Observable，它可以轉發它收到(Observe)的數據，
也可以發射新的數據。

由於一個Subject訂閱一個Observable，它可以觸發這個Observable開始發射數據
（如果那個Observable是"冷"的--就是說，它等待有訂閱才開始發射數據）。
因此有這樣的效果，Subject可以把原來那個"冷"的Observable變成"熱"的。

*** Subject的種類
針對不同的場景一共有四種類型的Subject。他們並不是在所有的實現中全部都存在，
而且一些實現使用其它的命名約定（例如，在RxScala中Subject被稱作PublishSubject）。

**** AsyncSubject
一個AsyncSubject只在原始Observable完成後，發射來自原始Observable的最後一個值。
（如果原始Observable沒有發射任何值，AsyncObject也不發射任何值）它會把這最後一個值發射給任何後續的觀察者。

[[https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.AsyncSubject.png]]

然而，如果原始的Observable因為發生了錯誤而終止，AsyncSubject將不會發射任何數據，只是簡單的向前傳遞這個錯誤通知。

[[https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.AsyncSubject.e.png]]

**** BehaviorSubject
當觀察者訂閱BehaviorSubject時，它開始發射原始Observable最近發射的數據
（如果此時還沒有收到任何數據，它會發射一個默認值），然後繼續發射其它任何來自原始Observable的數據。
[[https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.BehaviorSubject.png]]

然而，如果原始的Observable因為發生了一個錯誤而終止，BehaviorSubject將不會發射任何數據，只是簡單的向前傳遞這個錯誤通知。

[[https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.BehaviorSubject.e.png]]

**** PublishSubject
PublishSubject只會把在訂閱發生的時間點之後來自原始Observable的數據發射給觀察者。
需要注意的是，PublishSubject可能會一創建完成就立刻開始發射數據（除非你可以阻止它發生），
因此這裡有一個風險：在Subject被創建後到有觀察者訂閱它之前這個時間段內，一個或多個數據可能會丟失。
如果要確保來自原始Observable的所有數據都被分發，你需要這樣做：
或者使用Create創建那個Observable以便手動給它引入"冷"Observable的行為
（當所有觀察者都已經訂閱時才開始發射數據），或者改用ReplaySubject。

[[https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.PublishSubject.png]]

如果原始的Observable因為發生了一個錯誤而終止，PublishSubject將不會發射任何數據，只是簡單的向前傳遞這個錯誤通知。

[[https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.PublishSubject.e.png]]

**** ReplaySubject
ReplaySubject會發射所有來自原始Observable的數據給觀察者，無論它們是何時訂閱的。也有其它版本的ReplaySubject，
在重放緩存增長到一定大小的時候或過了一段時間後會丟棄舊的數據（原始Observable發射的）。

如果你把ReplaySubject當作一個觀察者使用，注意不要從多個線程中調用它的onNext方法（包括其它的on系列方法），
這可能導致同時（非順序）調用，這會違反Observable協議，給Subject的結果增加了不確定性。

[[https://mcxiaoke.gitbooks.io/rxdocs/content/images/S.ReplaySubject.png]]

*** RxJava的對應類
假設你有一個Subject，你想把它傳遞給其它的代理或者暴露它的Subscriber接口，你可以調用它的asObservable方法，
這個方法返回一個Observable。具體使用方法可以參考Javadoc文檔。

**** 串行化
如果你把Subject 當作一個Subscriber 使用，注意不要從多個線程中調用它的onNext方法（包括其它的on系列方法），
這可能導致同時（非順序）調用，這會違反Observable協議，給Subject的結果增加了不確定性。

要避免此類問題，你可以將 Subject 轉換為一個 SerializedSubject ，類似於這樣：

#+NAME:
#+BEGIN_SRC
mySafeSubject = new SerializedSubject( myUnsafeSubject );
#+END_SRC

** 調度器 Scheduler
如果你想給Observable操作符鏈添加多線程功能，你可以指定操作符（或者特定的Observable）在特定的調度器(Scheduler)上執行。

某些ReactiveX的Observable操作符有一些變體，它們可以接受一個Scheduler參數。
這個參數指定操作符將它們的部分或全部任務放在一個特定的調度器上執行。

使用ObserveOn和SubscribeOn操作符，你可以讓Observable在一個特定的調度器上執行，
ObserveOn指示一個Observable在一個特定的調度器上調用觀察者的 onNext, onError和onCompleted方法，
SubscribeOn更進一步，它指示Observable將全部的處理過程（包括發射數據和通知）放在特定的調度器上執行。

*** RxJava 示例

**** 調度器的種類
下表展示了RxJava中可用的調度器種類：

| 調度器類型                | 效果                                                                                                              |
|---------------------------+-------------------------------------------------------------------------------------------------------------------|
| Schedulers.computation()  | 用於計算任務，如事件循環或和回調處理，不要用於IO操作(IO操作請使用Schedulers.io())；默認線程數等於處理器的數量     |
| Schedulers.from(executor) | 使用指定的Executor作為調度器                                                                                      |
| Schedulers.immediate()    | 在當前線程立即開始執行任務                                                                                        |
| Schedulers.io()           | 用於IO密集型任務，如異步阻塞IO操作，這個調度器的線程池會根據需要增長；對於普通的計算任務，                        |
|                           | 請使用Schedulers.computation()；Schedulers.io( )默認是一個CachedThreadScheduler，很像一個有線程緩存的新線程調度器 |
| Schedulers.newThread()    | 為每個任務創建一個新線程                                                                                          |
| Schedulers.trampoline()   | 當其它排隊的任務完成後，在當前線程排隊開始執行                                                                    |

**** 默認調度器
在RxJava中，某些Observable操作符的變體允許你設置用於操作執行的調度器，其它的則不在任何特定的調度器上執行，
或者在一個指定的默認調度器上執行。下面的表格個列出了一些操作符的默認調度器：

| 操作符                                                | 调度器      |
|-------------------------------------------------------+-------------|
| buffer(timespan)                                      | computation |
| buffer(timespan, count)                               | computation |
| buffer(timespan, timeshift)                           | computation |
| debounce(timeout, unit)                               | computation |
| delay(delay, unit)                                    | computation |
| delaySubscription(delay, unit)                        | computation |
| interval                                              | computation |
| repeat                                                | trampoline  |
| replay(time, unit)                                    | computation |
| replay(buffersize, time, unit)                        | computation |
| replay(selector, time, unit)                          | computation |
| replay(selector, buffersize, time, unit)              | computation |
| retry                                                 | trampoline  |
| sample(period, unit)                                  | computation |
| skip(time, unit)                                      | computation |
| skipLast(time, unit)                                  | computation |
| take(time, unit)                                      | computation |
| takeLast(time, unit)                                  | computation |
| takeLast(count, time, unit)                           | computation |
| takeLastBuffer(time, unit)                            | computation |
| takeLastBuffer(count, time, unit)                     | computation |
| throttleFirst                                         | computation |
| throttleLast                                          | computation |
| throttleWithTimeout                                   | computation |
| timeInterval                                          | immediate   |
| timeout(timeoutSelector)                              | immediate   |
| timeout(firstTimeoutSelector, timeoutSelector)        | immediate   |
| timeout(timeoutSelector, other)                       | immediate   |
| timeout(timeout, timeUnit)                            | computation |
| timeout(firstTimeoutSelector, timeoutSelector, other) | immediate   |
| timeout(timeout, timeUnit, other)                     | computation |
| timer                                                 | computation |
| timestamp                                             | immediate   |
| window(timespan)                                      | computation |
| window(timespan, count)                               | computation |
| window(timespan, timeshift)                           | computation |

**** 使用調度器
除了將這些調度器傳遞給RxJava的Observable操作符，你也可以用它們調度你自己的任務。
下面的示例展示了Scheduler.Worker的用法：

#+NAME:
#+BEGIN_SRC
worker = Schedulers.newThread().createWorker();
worker.schedule(new Action0() {

    @Override
    public void call() {
        yourWork();
    }

});
// some time later...
worker.unsubscribe();
#+END_SRC

**** 遞迴調度器
要調度遞迴的方法調用，你可以使用schedule，然後再用schedule(this)，示例：

#+NAME:
#+BEGIN_SRC
worker = Schedulers.newThread().createWorker();
worker.schedule(new Action0() {

    @Override
    public void call() {
        yourWork();
        // recurse until unsubscribed (schedule will do nothing if unsubscribed)
        worker.schedule(this);
    }

});
// some time later...
worker.unsubscribe();
#+END_SRC

**** 檢查或設置取消訂閱狀態
Worker類的對象實現了Subscription接口，使用它的isUnsubscribed和unsubscribe方法，
所以你可以在訂閱取消時停止任務，或者從正在調度的任務內部取消訂閱，示例：

#+NAME:
#+BEGIN_SRC
Worker worker = Schedulers.newThread().createWorker();
Subscription mySubscription = worker.schedule(new Action0() {

    @Override
    public void call() {
        while(!worker.isUnsubscribed()) {
            status = yourWork();
            if(QUIT == status) { worker.unsubscribe(); }
        }
    }

});
#+END_SRC

Worker同時是Subscription，因此你可以（通常也應該）調用它的unsubscribe方法通知可以掛起任務和釋放資源了。

**** 延時和周期調度器

你可以使用schedule(action,delayTime,timeUnit)在指定的調度器上延時執行你的任務，下面例子中的任務將在500毫秒之後開始執行：

#+NAME:
#+BEGIN_SRC
someScheduler.schedule(someAction, 500, TimeUnit.MILLISECONDS);
#+END_SRC

使用另一個版本的schedule，schedulePeriodically(action,initialDelay,period,timeUnit)方法讓你可以安排一個定期執行的任務，
下面例子的任務將在500毫秒之後執行，然後每250毫秒執行一次：

#+NAME:
#+BEGIN_SRC
someScheduler.schedulePeriodically(someAction, 500, 250, TimeUnit.MILLISECONDS);
#+END_SRC

**** 測試調度器
TestScheduler讓你可以對調度器的時鐘錶現進行手動微調。這對依賴精確時間安排的任務的測試很有用處。
這個調度器有三個額外的方法：

1. advanceTimeTo(time,unit) 向前波動調度器的時鐘到一個指定的時間點
2. advanceTimeBy(time,unit) 將調度器的時鐘向前撥動一個指定的時間段
3. triggerActions() 開始執行任何計劃中的但是未啟動的任務，如果它們的計劃時間等於或者早於調度器時鐘的當前時間

** Operators

*** 操作符分類
ReactiveX的每種編程語言的實現都實現了一組操作符的集合。不同的實現之間有很多重疊的部分，也有一些操作符只存在特定的實現中。
每種實現都傾向於用那種編程語言中他們熟悉的上下文中相似的方法給這些操作符命名。

本文首先會給出ReactiveX的核心操作符列表和對應的文檔鏈接，後面還有一個決策樹用於幫助你根據具體的場景選擇合適的操作符。
最後有一個語言特定實現的按字母排序的操作符列表。

如果你想實現你自己的操作符，可以參考這裡：[[https://mcxiaoke.gitbooks.io/rxdocs/content/topics/Implementing-Your-Own-Operators.html][實現自定義操作符]]

**** 創建操作
用於創建Observable的操作符

***** create
通過調用觀察者的方法從頭創建一個Observable

***** Defer
在觀察者訂閱之前不創建這個Observable，為每一個觀察者創建一個新的Observable

***** Empty/Never/Throw
創建行為受限的特殊Observable

***** From
將其它的對像或數據結構轉換為Observable

***** Interval
創建一個定時發射整數序列的Observable

***** Just
將對像或者對象集合轉換為一個會發射這些對象的Observable

***** Range
創建發射指定範圍的整數序列的Observable

***** Repeat
創建重複發射特定的數據或數據序列的Observable

***** Start
創建發射一個函數的返回值的Observable

***** Timer
創建在一個指定的延遲之後發射單個數據的Observable

**** 變換操作
這些操作符可用於對Observable發射的數據進行變換，詳細解釋可以看每個操作符的文檔

***** Buffer
緩存，可以簡單的理解為緩存，它定期從Observable收集數據到一個集合，然後把這些數據集合打包發射，而不是一次發射一個

***** FlatMap
扁平映射，將Observable發射的數據變換為Observables集合，然後將這些Observable發射的數據平坦化的放進一個單獨的Observable，
可以認為是一個將嵌套的數據結構展開的過程。

***** GroupBy
分組，將原來的Observable分拆為Observable集合，將原始Observable發射的數據按Key分組，每一個Observable發射一組不同的數據

***** Map
映射，通過對序列的每一項都應用一個函數變換Observable發射的數據，實質是對序列中的每一項執行一個函數，函數的參數就是這個數據項

***** Scan
掃描，對Observable發射的每一項數據應用一個函數，然後按順序依次發射這些值

***** Window
窗口，定期將來自Observable的數據分拆成一些Observable窗口，然後發射這些窗口，而不是每次發射一項。類似於Buffer，
但Buffer發射的是數據，Window發射的是Observable，每一個Observable發射原始Observable的數據的一個子集

**** 過濾操作
這些操作符用於從Observable發射的數據中進行選擇

***** Debounce
只有在空閒了一段時間後才發射數據，通俗的說，就是如果一段時間沒有操作，就執行一次操作

***** Distinct
去重，過濾掉重複數據項

***** ElementAt
取值，取特定位置的數據項

***** Filter
過濾，過濾掉沒有通過謂詞測試的數據項，只發射通過測試的

***** First
首項，只發射滿足條件的第一條數據

***** IgnoreElements
忽略所有的數據，只保留終止通知(onError或onCompleted)

***** List
末項，只發射最後一條數據

***** Sample
取樣，定期發射最新的數據，等於是數據抽樣，有的實現裡叫ThrottleFirst

***** Skip
跳過前面的若干項數據

***** SkipLast
跳過後面的若干項數據

***** Take
只保留前面的若干項數據

***** TakeLast
只保留後面的若干項數據

**** 組合操作
組合操作符用於將多個Observable組合成一個單一的Observable

***** And/Then/When
通過模式(And條件)和計劃(Then次序)組合兩個或多個Observable發射的數據集

***** CombineLatest
當兩個Observables中的任何一個發射了一個數據時，通過一個指定的函數組合每個Observable發射的最新數據（一共兩個數據），
然後發射這個函數的結果

***** Join
無論何時，如果一個Observable發射了一個數據項，只要在另一個Observable發射的數據項定義的時間窗口內，
就將兩個Observable發射的數據合併發射

***** Merge
將兩個Observable發射的數據組合併成一個

***** StartWith
在發射原來的Observable的數據序列之前，先發射一個指定的數據序列或數據項

***** Switch
將一個發射Observable序列的Observable轉換為這樣一個Observable：
它逐個發射那些Observable最近發射的數據

***** Zip
打包，使用一個指定的函數將多個Observable發射的數據組合在一起，然後將這個函數的結果作為單項數據發射

**** 錯誤處理
這些操作符用於從錯誤通知中恢復

***** Catch
捕獲，繼續序列操作，將錯誤替換為正常的數據，從onError通知中恢復

***** Retry
重試，如果Observable發射了一​​個錯誤通知，重新訂閱它，期待它正常終止

**** 輔助操作
一組用於處理Observable的操作符

***** Delay
延遲一段時間發射結果數據

***** Do
註冊一個動作佔用一些Observable的生命週期事件，相當於Mock某個操作

***** Materialize/Dematerialize
將發射的數據和通知都當做數據發射，或者反過來

***** ObserveOn
指定觀察者觀察Observable的調度程序（工作線程）

***** Serialize
強制Observable按次序發射數據並且功能是有效的

***** Subscribe
收到Observable發射的數據和通知後執行的操作

***** SubscribeOn
指定Observable應該在哪個調度程序上執行

***** TimeInterval
將一個Observable轉換為發射兩個數據之間所耗費時間的Observable

***** Timeout
添加超時機制，如果過了指定的一段時間沒有發射數據，就發射一個錯誤通知

***** Timestamp
給Observable發射的每個數據項添加一個時間戳

***** Using
創建一個只在Observable的生命週期內存在的一次性資源

**** 條件和布林操作
這些操作符可用於單個或多個數據項，也可用於Observable

***** All
判斷Observable發射的所有的數據項是否都滿足某個條件

***** Amb
給定多個Observable，只讓第一個發射數據的Observable發射全部數據

***** Contains
判斷Observable是否會發射一個指定的數據項

***** DefaultIfEmpty
發射來自原始Observable的數據，如果原始Observable沒有發射數據，就發射一個默認數據

***** SequenceEqual
判斷兩個Observable是否按相同的數據序列

***** SkipUntil
丟棄原始Observable發射的數據，直到第二個Observable發射了一個數據，然後發射原始Observable的剩餘數據

***** SkipWhile
丟棄原始Observable發射的數據，直到一個特定的條件為假，然後發射原始Observable剩餘的數據

***** TakeUntil
發射來自原始Observable的數據，直到第二個Observable發射了一個數據或一個通知

***** TakeWhile
發射原始Observable的數據，直到一個特定的條件為真，然後跳過剩餘的數據

**** 算術和聚合操作
這些操作符可用於整個數據序列

***** Average
計算Observable發射的數據序列的平均值，然後發射這個結果

***** Concat
不交錯的連接多個Observable的數據

***** Count
計算Observable發射的數據個數，然後發射這個結果

***** Max
計算並發射數據序列的最大值

***** Min
計算並發射數據序列的最小值

***** Reduce
按順序對數據序列的每一個應用某個函數，然後返回這個值

***** Sum
計算並發射數據序列的和

**** 異步操作
下面的這些操作符屬於單獨的rxjava-async模塊，它們用於將同步對象轉換為Observable。

***** start()
創建一個Observable，它發射一個函數的返回值

***** toAsync() or asyncAction() or asyncFunc()
將一個函數或者Action轉換為已Observable，它執行這個函數並發射函數的返回值

***** startFuture()
將一個返回Future的函數轉換為一個Observable，它發射Future的返回值

***** deferFuture()
將一個返回Observable的Future轉換為一個Observable，但是並不嘗試獲取這個Future返回的Observable，
直到有訂閱者訂閱它

***** forEachFuture()
傳遞Subscriber方法給一個Subscriber，但是同時表現得像一個Future一樣阻塞直到它完成

***** fromAction()
將一個Action轉換為Observable，當一個訂閱者訂閱時，它執行這個action並發射它的返回值

***** fromCallable()
將一個Callable轉換為Observable，當一個訂閱者訂閱時，它執行這個Callable並發射Callable的返回值，或者發射異常

***** fromRunnable()
將一個Runnable轉換為Observable，當一個訂閱者訂閱時，它執行這個Runnable並發射Runnable的返回值

***** runAsync()
返回一個StoppableObservable，它發射某個Scheduler上指定的Action生成的多個actions

**** 連接操作
一些有精確可控的訂閱行為的特殊Observable

***** Connect
指示一個可連接的Observable開始發射數據給訂閱者

***** Publish
將一個普通的Observable轉換為可連接的

***** RefCount
使一個可連接的Observable表現得像一個普通的Observable

***** Replay
確保所有的觀察者收到同樣的數據序列，即使他們在Observable開始發射數據之後才訂閱

**** 轉換操作

***** To
將Observable轉換為其它的對像或數據結構

***** Blocking
阻塞Observable的操作符

**** 阻塞操作
這一節解釋 BlockingObservable 的子類. 一個阻塞的Observable 繼承普通的Observable類，
增加了一些可用於阻塞Observable發射的數據的操作符。

要將普通的Observable 轉換為 BlockingObservable，可以使用 Observable.toBlocking()) 方法
或者BlockingObservable.from()) 方法。

***** forEach()
對Observable發射的每一項數據調用一個方法，會阻塞直到Observable完成

***** first()
阻塞直到Observable發射了一個數據，然後返回第一項數據

***** firstOrDefault()
阻塞直到Observable發射了一個數據或者終止，返回第一項數據，或者返回默認值

***** last()
阻塞直到Observable終止，然後返回最後一項數據

***** lastOrDefault()
阻塞直到Observable終止，然後返回最後一項的數據，或者返回默認值

***** mostRecent()
返回一個總是返回Observable最近發射的數據的iterable

***** next()
返回一個Iterable，會阻塞直到Observable發射了另一個值，然後返回那個值

***** latest()
返回一個iterable，會阻塞直到或者除非Observable發射了一個iterable沒有返回的值，然後返回這個值

***** single()
如果Observable終止時只發射了一個值，返回那個值，否則拋出異常

***** singleOrDefault()
如果Observable終止時只發射了一個值，返回那個值，否則否好默認值

***** toFuture()
將Observable轉換為一個Future

***** toIterable()
將一個發射數據序列的Observable轉換為一個Iterable

***** getIterator()
將一個發射數據序列的Observable轉換為一個Iterator

***** 伴隨這個解釋還有一個修改版的彈珠圖，表示阻塞Observable的彈珠圖：
[[https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/B.legend.png]]

***** BlockingObservable的方法
BlockingObservable的方法不是將一個Observable變換為另一個，也不是過濾Observables，它們會打斷Observable的調用鏈，
會阻塞等待直到Observable發射了想要的數據，然後返回這個數據（而不是一個Observable）。

要將一個Observable轉換為一個BlockingObservable，你可以使用Observable.toBlocking或BlockingObservable.from方法。

Javadoc: Observable.toBlocking())
Javadoc: BlockingObservable.from(Observable))

****** first
[[https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/B.first.png]]

要獲取BlockingObservable的發射物，使用無參數的first方法。

Javadoc: BlockingObservable.first())

****** first.p
[[https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/B.first.p.png]]

你也可以給first方法傳遞一個謂詞函數用於獲取滿足條件的BlockingObservable。

Javadoc: BlockingObservable.first(Func1))

****** firstOrDefault
[[https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/B.firstOrDefault.png]]

和過濾操作符一樣，如果原始Observable沒有數據，first會拋出異常NoSuchElementException，firstOrDefault會返回一個默認值。

Javadoc: BlockingObservable.firstOrDefault())

****** firstOrDefault.p
[[https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/B.firstOrDefault.p.png]]


firstOrDefault同樣也接受一個謂詞函數作為參數，用於獲取滿足條件的第一項，如果沒有滿足條件的就返回默認值。

Javadoc: BlockingObservable.firstOrDefault(T, Func1))

****** single
[[https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/B.single.png]]

single和first類似，但是如果不是正好發射一個數據，會拋出異常NoSuchElementException。其它幾個變體的功能也是類似的。

Javadoc: single())

****** single.p
[[https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/B.single.p.png]]

同上，接受一個謂詞函數，如果滿足條件的不是正好一個，會拋出異常。

Javadoc: single(Func1))

****** singleOrDefault
[[https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/B.singleOrDefault.png]]

類似firstOrDefault，在為空時返回默認值，超過一個就拋出異常。

Javadoc: singleOrDefault(T))

****** singleOrDefault.p
[[https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/B.singleOrDefault.p.png]]


類似firstOrDefault，接受一個謂詞函數，如果沒有復合條件的，返回默認值；如果有多個複合條件的，以錯誤通知終止。

Javadoc: singleOrDefault(Func1,T))

****** next
[[https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/B.next.png]]

next操作符會阻塞直到BlockingObservable返回另外一個值，然後它返回那個值。你可以重複調用這個方法從BlockingObservable獲取後續的數據項。
以阻塞的方式高效的迭代獲取它的發射物。

latest操作符也是類似的，但是它不會阻塞等待下一個值，它立即返回最近發射的數據項，只在Observable還沒有發射任何數據時會阻塞。

Javadoc: next())
Javadoc: latest())

****** mostRecent
[[https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/B.mostRecent.png]]

mostRecent操作符讓你可以用類似的方式迭代一個BlockingObservable，但是它總是立即返回一個值，或者是默認值（如果BlockingObservable還沒有發射任何數據），
或者是BlockingObservable最近發射的數據項。

Javadoc: mostRecent(T))

****** forEach
BlockingObservable類中也有一個類似的叫作forEach的方法。要使用這個方法，你首先需要使用BlockingObservable.from方法或
Observable.toBlocking操作符將原始Observable轉換為一個BlockingObservable。

BlockingObservable.forEach接受單個函數作為參數，這個函數的作用類似於普通Observable訂閱中的onNext函數。
forEach自身會阻塞知道BlockingObservable完成，當它不阻塞時就是完成了，不是通過調用一個回調方法表示它完成了。
如果遇到了錯誤它將拋出一個RuntimeException（而不是調用一個類似於onError的回調方法）。

Javadoc: BlockingObservable.forEach(Action1))

****** 參見：
javadoc ： BlockingObservable
Javadoc ： toBlocking()
Javadoc ： BlockingObservable.from()

***** 附錄：相似的阻塞和非阻塞操作符列表

| 操作符                             | 發射多個數據的Observable | 發射單個數據的Observable | 不發射數據的Observable | Rx.NET等價操作       |
|------------------------------------+--------------------------+--------------------------+------------------------+----------------------|
| Observable.first                   | 第一項                   | 單個數據                 | 該元素不存在           | firstAsync           |
| BlockingObservable.first           | 第一項                   | 單個數據                 | 該元素不存在           | first                |
| Observable.firstOrDefault          | 第一項                   | 單個數據                 | 默認數據               | firstOrDefaultAsync  |
| BlockingObservable.firstOrDefault  | 第一項                   | 單個數據                 | 默認數據               | firstOrDefault       |
| Observable.last                    | 最後一項                 | 單個數據                 | 該元素不存在           | lastAsync            |
| BlockingObservable.last            | 最後一項                 | 單個數據                 | 該元素不存在           | last                 |
| Observable.lastOrDefault           | 最後一項                 | 單個數據                 | 默認數據               | lastOrDefaultAsync   |
| BlockingObservable.lastOrDefault   | 最後一項                 | 單個數據                 | 默認數據               | lastOrDefault        |
| Observable.single                  | 非法參數                 | 單個數據                 | 該元素不存在           | singleAsync          |
| BlockingObservable.single          | 非法參數                 | 單個數據                 | 該元素不存在           | single               |
| Observable.singleOrDefault         | 非法參數                 | 單個數據                 | 默認數據               | singleOrDefaultAsync |
| BlockingObservable.singleOrDefault | 非法參數                 | 單個數據                 | 默認數據               | singleOrDefault      |

**** 字符串操作
StringObservable 類包含一些用於處理字符串序列和流的特殊操作符，如下：

***** byLine()
將一個字符串的Observable轉換為一個行序列的Observable，這個Observable將原來的序列當做流處理，然後按換行符分割

***** decode()
將一個多字節的字符流轉換為一個Observable，它按字符邊界發射字節數組

***** encode()
對一個發射字符串的Observable執行變換操作，變換後的Observable發射一個在原始字符串中表示多字節字符邊界的字節數組

***** from()
將一個字符流或者Reader轉換為一個發射字節數組或者字符串的Observable

***** join()
將一個發射字符串序列的Observable轉換為一個發射單個字符串的Observable，後者用一個指定的字符串連接所有的字符串

***** split()
將一個發射字符串的Observable轉換為另一個發射字符串的Observable，後者使用一個指定的正則表達式邊界分割前者發射的所有字符串

***** stringConcat()
將一個發射字符串序列的Observable轉換為一個發射單個字符串的Observable，後者連接前者發射的所有字符串

**** 操作符決策樹
幾種主要的需求

1. 直接創建一個Observable（創建操作）
2. 組合多個Observable（組合操作）
3. 對Observable發射的數據執行變換操作（變換操作）
4. 從Observable發射的數據中取特定的值（過濾操作）
5. 轉發Observable的部分值（條件/布林/過濾操作）
6. 對Observable發射的數據序列求值（算術/聚合操作）
